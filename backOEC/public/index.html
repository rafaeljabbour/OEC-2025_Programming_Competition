<!-- disaster -->

<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Disaster App with Reroute & New-Hazard Warnings</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Mapbox GL JS -->
    <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
    <link href="https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />

    <!-- Mapbox GL Directions Plugin -->
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.1/mapbox-gl-directions.js">
    </script>
    <link rel="stylesheet"
        href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.1/mapbox-gl-directions.css"
        type="text/css" />

    <!-- Turf.js for geometry operations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 6px;
            padding: 16px;
            z-index: 2;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            width: 220px;
        }

        .ui-container h1 {
            margin: 0 0 1em 0;
            font-size: 1.2em;
            text-align: center;
        }

        .ui-button,
        .ui-input {
            display: block;
            width: 100%;
            margin: 0.5em 0;
            padding: 0.4em 0.6em;
            font-size: 1em;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .ui-button {
            cursor: pointer;
            background-color: #f8f8f8;
            transition: background-color 0.2s;
        }

        .ui-button:hover {
            background-color: #eee;
        }

        .mapboxgl-ctrl-top-left {
            margin-top: 10px;
            margin-left: 10px;
        }

        .mapboxgl-popup-content {
            max-width: 320px;
        }
    </style>
</head>

<body>
    <!-- Map -->
    <div id="map"></div>

    <!-- UI Container -->
    <div class="ui-container">
        <h1>Disaster App</h1>

        <button id="loginBtn" class="ui-button" onclick="window.location.href='/login.html'"
            style="background-color: #4CAF50; color: white; margin-bottom: 20px;">
            Login/Register
        </button>

        <!-- Toggle Disaster Modes -->
        <button id="toggleBlockBtn" class="ui-button">Enable Fire Mode</button>
        <button id="toggleFloodBtn" class="ui-button">Enable Flood Mode</button>
        <button id="toggleEarthquakeBtn" class="ui-button">Enable Earthquake Mode</button>
        <button id="toggleHurricaneBtn" class="ui-button" style="background-color: #ccc;">
            Enable Hurricane Mode
        </button>

        <!-- Custom Disaster Controls -->
        <h3 style="margin-top:1em;">Add Other Disaster</h3>
        <button id="addOtherDisasterBtn" class="ui-button">Add Other Disaster</button>
        <div id="customDisasterControls" style="display:none; margin-top:1em;">
            <input id="customColorInput" class="ui-input" type="text" placeholder="Marker color (e.g. #FF0000)" />
            <input id="customTypeInput" class="ui-input" type="text" placeholder="Disaster Type Name" />
            <button id="startCustomBtn" class="ui-button">Start Adding Custom Disaster</button>
        </div>

        <!-- Destination input -->
        <input id="destinationInput" class="ui-input" type="text" placeholder="Address or Lat,Lng..." />
        <button id="setDestBtn" class="ui-button">Set Destination</button>

        <!-- Refresh Map -->
        <button id="refreshBtn" class="ui-button">Refresh Map</button>
        <button id="focusMeBtn" class="ui-button">Focus on Me</button>
    </div>

    <script>
        'use strict';

        // ------------------------------------------
        // 0) TRACKING LAST REFRESH TIME
        // ------------------------------------------
        let lastRefreshTime = Date.now(); // numeric timestamp of last refresh

        // ------------------------------------------
        // 1) BASIC MAP & DIRECTIONS
        // ------------------------------------------
        mapboxgl.accessToken =
            'pk.eyJ1IjoicmFsZHV0ZWsiLCJhIjoiY202MmR5MDViMHlmMjJucG5mcWw4emo4ZSJ9.Ox0uAsJ9O66fBpsEUOMXlw';

        const defaultCenter = [-79.9177, 43.2609];
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v12',
            center: defaultCenter,
            zoom: 12
        });

        map.addControl(new mapboxgl.NavigationControl(), 'top-left');
        map.addControl(
            new mapboxgl.ScaleControl({ maxWidth: 100, unit: 'metric' }),
            'bottom-left'
        );

        const directions = new MapboxDirections({
            accessToken: mapboxgl.accessToken,
            unit: 'metric',
            profile: 'mapbox/driving',
            interactive: false,
            controls: {
                inputs: false,
                instructions: true
            }
        });
        map.addControl(directions, 'top-left');

        const bounds = [
            [-80.3, 43.0],  // SW corner
            [-78.9, 44.0]   // NE corner
        ];
        map.setMaxBounds(bounds);

        // ------------------------------------------
        // 2) USER LOCATION
        // ------------------------------------------
        let userLocation = null;
        let userMarker = null;

        if ('geolocation' in navigator) {
            navigator.geolocation.watchPosition(
                (position) => {
                    userLocation = [position.coords.longitude, position.coords.latitude];
                    if (!userMarker) {
                        userMarker = new mapboxgl.Marker({ color: 'green' })
                            .setLngLat(userLocation)
                            .addTo(map);
                    } else {
                        userMarker.setLngLat(userLocation);
                    }
                },
                (err) => {
                    console.warn('Geolocation error:', err);
                    userLocation = defaultCenter;
                    userMarker = new mapboxgl.Marker({ color: 'green' })
                        .setLngLat(userLocation)
                        .addTo(map);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        } else {
            userLocation = defaultCenter;
            userMarker = new mapboxgl.Marker({ color: 'green' })
                .setLngLat(userLocation)
                .addTo(map);
        }

        document.getElementById('focusMeBtn').addEventListener('click', () => {
            if (userLocation) {
                map.flyTo({ center: userLocation, zoom: 14 });
            }
        });

        // ------------------------------------------
        // 3) LOAD DISASTERS (Fires, Floods, Earthquakes, Hurricanes, Custom)
        // ------------------------------------------
        let allMarkers = [];
        let allDisasterBuffers = [];

        map.on('load', () => {
            loadSafeHavens();
            loadFires();
            loadFloods();
            loadEarthquakes();
            loadHurricanes();
            loadCustomDisasters();
        });

        async function loadSafeHavens() {
            try {
                const response = await fetch('/api/safe-havens');
                if (!response.ok) throw new Error('Failed to load safe havens');
                const data = await response.json();
                data.forEach(haven => createMarkerFromDoc(haven));
            } catch (err) {
                console.error('Failed to load safe havens:', err);
            }
        }
        async function loadFires() {
            try {
                const response = await fetch('/api/fires');
                if (!response.ok) throw new Error('Failed to load fires');
                const data = await response.json();
                data.forEach(fireDoc => createMarkerFromDoc(fireDoc));
            } catch (err) {
                console.error('Failed to load fires:', err);
            }
        }
        async function loadFloods() {
            try {
                const resp = await fetch('/api/floods');
                if (!resp.ok) throw new Error('Failed to load floods');
                const data = await resp.json();
                data.forEach(floodDoc => createMarkerFromDoc(floodDoc));
            } catch (err) {
                console.error('Failed to load floods:', err);
            }
        }
        async function loadEarthquakes() {
            try {
                const resp = await fetch('/api/earthquakes');
                if (!resp.ok) throw new Error('Failed to load earthquakes');
                const data = await resp.json();
                data.forEach(eqDoc => createMarkerFromDoc(eqDoc));
            } catch (err) {
                console.error('Failed to load earthquakes:', err);
            }
        }
        async function loadHurricanes() {
            try {
                const resp = await fetch('/api/hurricanes');
                if (!resp.ok) throw new Error('Failed to load hurricanes');
                const data = await resp.json();
                data.forEach(hurrDoc => createMarkerFromDoc(hurrDoc));
            } catch (err) {
                console.error('Failed to load hurricanes:', err);
            }
        }
        async function loadCustomDisasters() {
            try {
                const resp = await fetch('/api/custom');
                if (!resp.ok) throw new Error('Failed to load custom pins');
                const data = await resp.json();
                data.forEach(customDoc => createMarkerFromDoc(customDoc));
            } catch (err) {
                console.error('Failed to load custom pins:', err);
            }
        }

        const REFRESH_INTERVAL = 10000; // 30 seconds

        async function refreshMap() {
            // 1) Remove all existing markers
            allMarkers.forEach(marker => marker.remove());
            allMarkers = [];
            allDisasterBuffers = [];

            // 2) Keep track of previous refresh time
            const prevRefresh = lastRefreshTime;
            lastRefreshTime = Date.now();

            // 3) Reload everything
            await Promise.all([
                loadSafeHavens(),
                loadFires(),
                loadFloods(),
                loadEarthquakes(),
                loadHurricanes(),
                loadCustomDisasters()
            ]);

            // 4) Check for newly added hazards within 20 km
            //    "New" meaning doc.createdAt > prevRefresh
            const newWithinRange = [];
            if (userLocation) {
                allMarkers.forEach(marker => {
                    const doc = marker.__docData;
                    if (!doc || !doc.createdAt) return;
                    const docTime = new Date(doc.createdAt).getTime();
                    if (docTime <= prevRefresh) return; // not new this cycle

                    // Check distance
                    const distanceKm = turf.distance(
                        turf.point(userLocation),
                        turf.point(doc.coords),
                        { units: 'kilometers' }
                    );
                    if (distanceKm <= 20) {
                        newWithinRange.push(doc);
                    }
                });
            }

            // If we have new hazards within 20 km, alert the user
            if (newWithinRange.length > 0) {
                let msg = 'New Disasters within 20 km:\n';
                newWithinRange.forEach(d => {
                    const when = new Date(d.createdAt).toLocaleString();
                    msg += `- ${d.type}, added at ${when}\n`;
                });
                alert(msg);
            }

            // 5) If we have an active destination, re-check route in case hazards block it
            if (customDestinationActive && directions.getDestination()) {
                directions.setOrigin(directions.getOrigin());
                directions.setDestination(directions.getDestination());
            }
        }

        document.getElementById('refreshBtn').addEventListener('click', refreshMap);
        setInterval(refreshMap, REFRESH_INTERVAL);

        // ------------------------------------------
        // 4) CREATE MARKER FROM DOC
        // ------------------------------------------
        function createMarkerFromDoc(doc) {
            let color = '#000';
            if (doc.type === 'Fire') {
                color = '#FF0000';
            } else if (doc.type === 'SafeHaven') {
                color = '#FFFF00';
            } else if (doc.type === 'Flood') {
                color = '#0000FF';
            } else if (doc.type === 'Earthquake') {
                color = '#8B4513';
            } else if (doc.type === 'Hurricane') {
                color = '#808080';
            } else if (doc.type === 'Custom' && doc.color) {
                color = doc.color;
            }

            // If it's not a SafeHaven, add a hazard buffer for route avoidance
            if (doc.type !== 'SafeHaven' && doc.coords && doc.coords.length === 2) {
                const hazardPoint = turf.point(doc.coords);
                const bufferPoly = turf.buffer(hazardPoint, 0.02, { units: 'kilometers' });
                allDisasterBuffers.push(bufferPoly);
            }

            // Create the marker
            const marker = new mapboxgl.Marker({ color })
                .setLngLat(doc.coords)
                .addTo(map);

            // Store doc data on the marker (used later in refresh checks)
            marker.__docData = doc;
            allMarkers.push(marker);

            // Build popup
            const popupHTML = getPopupHTML(doc);
            const popup = new mapboxgl.Popup({ offset: 25 }).setHTML(popupHTML);
            marker.setPopup(popup);

            popup.on('open', () => {
                attachPopupListeners(popup, doc, marker);
            });

            return marker;
        }

        function getPopupHTML(doc) {
            const edits = doc.notes || [];
            const editsHTML = edits
                .map(e => `<li><strong>${e.time}:</strong> ${e.text}</li>`)
                .join('');
            const editHistory = editsHTML
                ? `<p><strong>Edit History:</strong></p><ul>${editsHTML}</ul>`
                : '';

            return `
        <h3>${doc.type}</h3>
        <p><strong>Time Placed:</strong> ${new Date(doc.createdAt).toLocaleString()}</p>
        
        <label for="popupNoteInput">Note:</label>
        <textarea id="popupNoteInput" rows="2" style="width:100%;"></textarea>
        <button id="saveNoteBtn">Save Note</button>
        <button id="removeMarkerBtn" style="margin-left:8px;">Remove Marker</button>
        
        ${editHistory}
      `;
        }

        function attachPopupListeners(popup, doc, marker) {
            setTimeout(() => {
                const saveBtn = document.getElementById('saveNoteBtn');
                const removeBtn = document.getElementById('removeMarkerBtn');
                const textArea = document.getElementById('popupNoteInput');

                if (saveBtn && textArea) {
                    saveBtn.addEventListener('click', async () => {
                        const noteText = textArea.value.trim();
                        if (!noteText) return;

                        try {
                            const resp = await fetch(`/api/pins/${doc._id}/notes`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ text: noteText })
                            });
                            if (!resp.ok) throw new Error('Failed to save note');

                            const updatedDoc = await resp.json();
                            // Update local doc
                            doc.notes = updatedDoc.notes || [];

                            // Rebuild popup
                            popup.setHTML(getPopupHTML(doc));
                            popup.remove();
                            marker.togglePopup();

                            await refreshMap();
                        } catch (err) {
                            console.error('Error saving note:', err);
                        }
                    });
                }

                if (removeBtn) {
                    removeBtn.addEventListener('click', async () => {
                        marker.remove();
                        // Optionally remove from DB
                        try {
                            await fetch(`/api/pins/${doc._id}`, { method: 'DELETE' });
                            await refreshMap();
                        } catch (err) {
                            console.error('Error removing marker:', err);
                        }
                    });
                }
            }, 0);
        }

        // ------------------------------------------
        // 5) DISASTER MODES (Fire/Flood/Earthquake/Hurricane) + Custom
        // ------------------------------------------
        let fireMode = false;
        let floodMode = false;
        let earthquakeMode = false;
        let hurricaneMode = false;
        let customAddMode = false;

        let customColor = '#000000';
        let customType = 'Custom';

        const toggleBlockBtn = document.getElementById('toggleBlockBtn');
        const toggleFloodBtn = document.getElementById('toggleFloodBtn');
        const toggleEarthquakeBtn = document.getElementById('toggleEarthquakeBtn');
        const toggleHurricaneBtn = document.getElementById('toggleHurricaneBtn');
        const addOtherDisasterBtn = document.getElementById('addOtherDisasterBtn');
        const startCustomBtn = document.getElementById('startCustomBtn');

        toggleBlockBtn.addEventListener('click', () => {
            fireMode = !fireMode;
            if (fireMode) {
                floodMode = false; earthquakeMode = false; hurricaneMode = false; customAddMode = false;
                toggleFloodBtn.textContent = 'Enable Flood Mode';
                toggleEarthquakeBtn.textContent = 'Enable Earthquake Mode';
                toggleHurricaneBtn.textContent = 'Enable Hurricane Mode';
            }
            toggleBlockBtn.textContent = fireMode ? 'Disable Fire Mode' : 'Enable Fire Mode';
        });
        toggleFloodBtn.addEventListener('click', () => {
            floodMode = !floodMode;
            if (floodMode) {
                fireMode = false; earthquakeMode = false; hurricaneMode = false; customAddMode = false;
                toggleBlockBtn.textContent = 'Enable Fire Mode';
                toggleEarthquakeBtn.textContent = 'Enable Earthquake Mode';
                toggleHurricaneBtn.textContent = 'Enable Hurricane Mode';
            }
            toggleFloodBtn.textContent = floodMode ? 'Disable Flood Mode' : 'Enable Flood Mode';
        });
        toggleEarthquakeBtn.addEventListener('click', () => {
            earthquakeMode = !earthquakeMode;
            if (earthquakeMode) {
                fireMode = false; floodMode = false; hurricaneMode = false; customAddMode = false;
                toggleBlockBtn.textContent = 'Enable Fire Mode';
                toggleFloodBtn.textContent = 'Enable Flood Mode';
                toggleHurricaneBtn.textContent = 'Enable Hurricane Mode';
            }
            toggleEarthquakeBtn.textContent = earthquakeMode
                ? 'Disable Earthquake Mode'
                : 'Enable Earthquake Mode';
        });
        toggleHurricaneBtn.addEventListener('click', () => {
            hurricaneMode = !hurricaneMode;
            if (hurricaneMode) {
                fireMode = false; floodMode = false; earthquakeMode = false; customAddMode = false;
                toggleBlockBtn.textContent = 'Enable Fire Mode';
                toggleFloodBtn.textContent = 'Enable Flood Mode';
                toggleEarthquakeBtn.textContent = 'Enable Earthquake Mode';
            }
            toggleHurricaneBtn.textContent = hurricaneMode
                ? 'Disable Hurricane Mode'
                : 'Enable Hurricane Mode';
        });

        addOtherDisasterBtn.addEventListener('click', () => {
            const panel = document.getElementById('customDisasterControls');
            panel.style.display = (panel.style.display === 'none' || !panel.style.display)
                ? 'block'
                : 'none';
        });

        startCustomBtn.addEventListener('click', () => {
            const colorInput = document.getElementById('customColorInput').value.trim();
            const typeInput = document.getElementById('customTypeInput').value.trim();
            if (!colorInput || !typeInput) {
                alert('Please enter both a color and a disaster name.');
                return;
            }
            customColor = colorInput;
            customType = typeInput;

            customAddMode = true;
            fireMode = false; floodMode = false; earthquakeMode = false; hurricaneMode = false;

            toggleBlockBtn.textContent = 'Enable Fire Mode';
            toggleFloodBtn.textContent = 'Enable Flood Mode';
            toggleEarthquakeBtn.textContent = 'Enable Earthquake Mode';
            toggleHurricaneBtn.textContent = 'Enable Hurricane Mode';

            alert('Click on the map to place your custom disaster marker.');
            document.getElementById('customDisasterControls').style.display = 'none';
        });

        // ------------------------------------------
        // 6) CREATE MARKERS ON MAP CLICK => POST to server
        //    (Then attempt real-time reroute if we have a route)
        // ------------------------------------------
        map.on('click', async (event) => {
            if (
                !fireMode && !floodMode &&
                !earthquakeMode && !hurricaneMode &&
                !customAddMode
            ) {
                return;
            }
            if (!userLocation) return; // must have user location to proceed

            const lngLat = [event.lngLat.lng, event.lngLat.lat];
            let endpoint = '/api/fires'; // default
            let docType = 'Fire';

            if (floodMode) {
                endpoint = '/api/floods';
                docType = 'Flood';
            } else if (earthquakeMode) {
                endpoint = '/api/earthquakes';
                docType = 'Earthquake';
            } else if (hurricaneMode) {
                endpoint = '/api/hurricanes';
                docType = 'Hurricane';
            } else if (customAddMode) {
                endpoint = '/api/custom';
                docType = customType;
            }

            const postBody = { coords: lngLat, type: docType };
            if (customAddMode) {
                postBody.color = customColor;
                postBody.customType = customType;
            }

            try {
                const resp = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(postBody)
                });
                if (!resp.ok) {
                    throw new Error(`Failed to create pin at ${endpoint}`);
                }
                const createdDoc = await resp.json();

                // Place on map
                const newDoc = {
                    _id: createdDoc.insertedId,
                    type: docType,
                    coords: lngLat,
                    color: (customAddMode ? customColor : undefined),
                    notes: [],
                    createdAt: new Date().toISOString()
                };
                createMarkerFromDoc(newDoc);

                // Reroute immediately if there's an active destination
                if (customDestinationActive && directions.getDestination()) {
                    directions.setOrigin(directions.getOrigin());
                    directions.setDestination(directions.getDestination());
                }
            } catch (err) {
                console.error('Error creating new pin:', err);
            }

            if (customAddMode) {
                customAddMode = false;
            }
        });

        // ------------------------------------------
        // 7) ROUTE AVOIDANCE
        // ------------------------------------------
        let customDestinationActive = false;
        const destinationInput = document.getElementById('destinationInput');
        const setDestBtn = document.getElementById('setDestBtn');

        setDestBtn.addEventListener('click', () => {
            const inputValue = destinationInput.value.trim();
            if (!inputValue) {
                alert('Please enter a destination (address or lat,lng).');
                return;
            }
            customDestinationActive = true;

            directions.setOrigin(userLocation || defaultCenter);

            const coords = inputValue.split(',');
            if (coords.length === 2) {
                const lat = parseFloat(coords[0]);
                const lng = parseFloat(coords[1]);
                if (!isNaN(lat) && !isNaN(lng)) {
                    directions.setDestination([lng, lat]);
                    return;
                }
            }
            directions.setDestination(inputValue);
        });

        // Filter out routes that intersect hazards
        directions.on('route', (e) => {
            const routes = e.route;
            const safeRoutes = routes.filter((route) => {
                const routeLine = turf.lineString(route.geometry.coordinates);
                // If route intersects any hazard buffer, exclude it
                for (let buffer of allDisasterBuffers) {
                    if (!turf.booleanDisjoint(routeLine, buffer)) {
                        return false;
                    }
                }
                return true;
            });

            if (safeRoutes.length === 0) {
                alert('No route found that avoids all disasters!');
            } else {
                // Overwrite the plugin's routes with safe subset
                directions.setRoutes(safeRoutes);
            }
        });
    </script>
</body>

</html>